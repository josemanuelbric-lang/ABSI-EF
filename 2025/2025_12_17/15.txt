import numpy as np
import math

def analizar_metasistema_collatz(n):
    temp = n
    firma_bits = [] # 1 para (b/ascenso), 0 para (a/descenso)
    
    while temp > 1:
        if temp % 2 == 0:
            firma_bits.append(0)
            temp //= 2
        else:
            firma_bits.append(1)
            temp = 3 * temp + 1
            
    # 1. Función de Potencial (Balance logarítmico entre 3 y 2)
    # Basado en la relación irracional log2(3)
    L = sum(firma_bits)
    R = len(firma_bits) - L
    potencial = L * math.log2(3) - R 
    
    # 2. Autocorrelación de la Firma (Lag 1 a L/2)
    # Detecta si el número está entrando en un "bucle" o ciclo
    def calcular_autocorr(bits):
        n = len(bits)
        if n < 4: return 0
        corrs = []
        for lag in range(1, n // 2):
            c = np.corrcoef(bits[:-lag], bits[lag:])[0, 1]
            if not np.isnan(c): corrs.append(c)
        return np.mean(corrs) if corrs else 0

    # 3. Índice de Complejidad de Filtrado (ICF)
    # Relación entre la profundidad x y el valor inicial N
    icf = len(firma_bits) / math.log2(n) if n > 1 else 0

    return {
        "N": n,
        "Potencial_Psi": potencial,
        "Autocorr_Ciclo": calcular_autocorr(firma_bits),
        "ICF": icf,
        "Profundidad_x": len(firma_bits)
    }

# --- Prueba con el 27 (Alta complejidad) y el 128 (Baja complejidad) ---
numeros = [27, 128, 1023]
for num in numeros:
    res = analizar_metasistema_collatz(num)
    print(f"\n--- Análisis Analítico para N={num} ---")
    print(f"Potencial de Descenso (Ψ): {res['Potencial_Psi']:.4f}")
    print(f"Probabilidad de Ciclo (Autocorr): {res['Autocorr_Ciclo']:.4f}")
    print(f"Complejidad de Filtrado (ICF): {res['ICF']:.4f}")