import numpy as np

# --- 1. Generador Convencional de Primos (Criba de Eratóstenes) ---
def generar_n_primos(n_max):
    """
    Genera una lista con los primeros n_max números primos.
    Se utiliza una criba optimizada (criba de Eratóstenes).
    """
    if n_max < 1:
        return []

    # El n-ésimo primo (p_n) es aproximadamente n * ln(n). 
    # Usamos una cota superior segura para el valor máximo que el primo 100 podría ser.
    # p_100 es 541. Usaremos una cota basada en Rosser/Schoenfeld: n(ln(n) + ln(ln(n)))
    # Para n=100, el valor es aproximadamente 100 * (4.6 + 1.5) = 610. Usaremos 650 para seguridad.
    
    # Si n_max es muy grande, se necesita una forma más precisa de acotar M.
    M = int(n_max * (np.log(n_max) + np.log(np.log(n_max))))
    
    if n_max <= 6:
        # Aseguramos que la cota M sea al menos 15 para los primeros primos.
        M = max(15, M) 

    es_primo = np.ones(M + 1, dtype=bool)
    es_primo[0:2] = False # 0 y 1 no son primos

    for p in range(2, int(np.sqrt(M)) + 1):
        if es_primo[p]:
            # Marcar múltiplos del primo actual
            es_primo[p*p : M+1 : p] = False

    primos = np.where(es_primo)[0]
    
    # Devolver solo los primeros n_max primos
    return primos[:n_max].tolist()

# --- 2. Fórmula Analítica para el n-ésimo Primo (Aproximación de la UDT) ---
def p_n_formula_udt(n):
    # La fórmula analítica avanzada de la UDT (inspirada en Rosser/Schoenfeld).
    if n < 1:
        return 0
    elif n == 1:
        return 2 # p_1 = 2
    
    # Costo de Tensión Entrópica (n * ln(n))
    costo_vacio = n * np.log(n)
    
    # Corrección de Resonancia (Términos logarítmicos avanzados)
    correccion_resonancia = n * (np.log(np.log(n)) - 1) 
    
    # Tercer término (refleja correcciones de orden superior de la geometría)
    # Se utiliza la estructura del tercer término de la aproximación de p_n
    correccion_orden_superior = (n * (np.log(np.log(n)) - 2)) / np.log(n)
    
    return int(costo_vacio + correccion_resonancia - correccion_orden_superior)

# =========================================================================
# --- CÓDIGO PRINCIPAL PARA LA VERIFICACIÓN ---
# =========================================================================

# Definimos el número máximo de primos a comprobar
N_MAXIMO = 100

# 1. Obtener la lista de los N_MAXIMO primos reales
primos_reales_100 = generar_n_primos(N_MAXIMO)

print(f"### Verificación de la FÓRMULA ANALÍTICA UDT para los primeros {N_MAXIMO} primos ###")
print(f"{'n':<4}{'P_n Real':<10}{'P_n Simple (Tensión)':<22}{'P_n UDT (Resonancia)':<25}{'Error UDT':<10}")
print("-" * 75)

# 2. Aplicar la Fórmula Analítica UDT a los primeros N_MAXIMO primos
for i in range(1, N_MAXIMO + 1):
    n = i
    p_real = primos_reales_100[i-1]
    
    # 1. Predicción Ingenua (Solo Tensión)
    p_simple = int(n * np.log(n))
    
    # 2. Predicción UDT (Resonancia Dimensional)
    p_udt = p_n_formula_udt(n)
    
    error_udt = p_udt - p_real
    print(f"{n:<4}{p_real:<10}{p_simple:<22}{p_udt:<25}{error_udt:<10}")

print("\n--- Resultados clave (Para n=100) ---")
print(f"n=100: P_100 Real = {primos_reales_100[-1]}")
print(f"n=100: P_100 UDT  = {p_n_formula_udt(100)}")
print(f"n=100: Error UDT  = {p_n_formula_udt(100) - primos_reales_100[-1]}")