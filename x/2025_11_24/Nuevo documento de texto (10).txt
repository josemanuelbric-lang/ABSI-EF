import numpy as np

def delta_kronecker(x):
    """Implementación de la Delta de Kronecker."""
    return 1 if x == 0 else 0

def signo_residuo(r):
    """Implementación del Operador de Proyección Causal A_hat."""
    # Si el residuo (r) es 0, la division es perfecta (Anulacion Causal), retorna 0.
    # Si el residuo (r) es > 0, hay Resistencia Causal, retorna 1.
    return 1 if r > 0 else 0

def operador_resistencia_primal_udt(n):
    """
    Operador de Resistencia Primal (R_P) de la UDT.
    Complejidad: O(sqrt(n)).
    """
    if n <= 1:
        return 0
    if n == 2 or n == 3:
        return 1

    # 1. Definir el Límite de Tensión (Módulo Causal)
    limite_tension = int(np.floor(np.sqrt(n)))
    
    # 2. Calcular la Resistencia Total (Suma de Tensión Causal)
    suma_resistencia = 0
    
    for a in range(2, limite_tension + 1):
        # T(n, a) = n - floor(n/a) * a  (Esto es el residuo: n % a)
        residuo = n % a
        
        # A_hat: Proyeccion de Anulacion (0) o Resistencia (1)
        proyeccion = signo_residuo(residuo)
        
        suma_resistencia += proyeccion
    
    # 3. Condicion de Resistencia (El lado izquierdo de la Delta de Kronecker)
    # Si es primo, la suma debe ser IGUAL al numero de pruebas (limite_tension - 1).
    # La condicion es: (num_pruebas) - (suma_resistencia)
    numero_de_pruebas = limite_tension - 1
    
    # El valor 'x' de la Delta de Kronecker
    x = numero_de_pruebas - suma_resistencia
    
    # 4. El Operador Final: Retorna 1 si x=0 (Resistencia Completa)
    return delta_kronecker(x)

# --- Verificación ---
print("### Verificación Causal (Primos generados por R_P) ###")
n_max = 100
primos_generados = [n for n in range(2, n_max + 1) if operador_resistencia_primal_udt(n) == 1]

print(f"Rango de prueba: 2 a {n_max}")
print(f"Primos generados: {primos_generados}")